{
  "name": "test-fixture",
  "version": "1.1.1",
  "description": "A simple element to fixture DOM for tests",
  "main": "test-fixture.html",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/polymerelements/test-fixture.git"
  },
  "keywords": [
    "web-components",
    "polymer",
    "testing"
  ],
  "author": {
    "name": "The Polymer Authors"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/polymerelements/test-fixture/issues"
  },
  "homepage": "https://github.com/polymerelements/test-fixture#readme",
  "readme": "\r\n<!---\r\n\r\nThis README is automatically generated from the comments in these files:\r\ntest-fixture.html\r\n\r\nEdit those files, and our readme bot will duplicate them over here!\r\nEdit this file, and the bot will squash your changes :)\r\n\r\nThe bot does some handling of markdown. Please file a bug if it does the wrong\r\nthing! https://github.com/PolymerLabs/tedium/issues\r\n\r\n-->\r\n\r\n[![Build status](https://travis-ci.org/PolymerElements/test-fixture.svg?branch=master)](https://travis-ci.org/PolymerElements/test-fixture)\r\n\r\n\r\n##&lt;test-fixture&gt;\r\n\r\nThe `<test-fixture>` element can simplify the exercise of consistently\r\nresetting a test suite's DOM. To use it, wrap the test suite's DOM as a template:\r\n\r\n```html\r\n<test-fixture id=\"SomeElementFixture\">\r\n  <template>\r\n    <some-element id=\"SomeElementForTesting\"></some-element>\r\n  </template>\r\n</test-fixture>\r\n```\r\n\r\nNow, the `<test-fixture>` element can be used to generate a copy of its\r\ntemplate:\r\n\r\n```html\r\n<script>\r\ndescribe('<some-element>', function () {\r\n  var someElement;\r\n\r\n  beforeEach(function () {\r\n    document.getElementById('SomeElementFixture').create();\r\n    someElement = document.getElementById('SomeElementForTesting');\r\n  });\r\n});\r\n</script>\r\n```\r\n\r\nFixtured elements can be cleaned up by calling `restore` on the `<test-fixture>`:\r\n\r\n```javascript\r\n  afterEach(function () {\r\n    document.getElementById('SomeElementFixture').restore();\r\n    // <some-element id='SomeElementForTesting'> has been removed\r\n  });\r\n```\r\n\r\n`<test-fixture>` will create fixtures from all of its immediate `<template>`\r\nchildren. The DOM structure of fixture templates can be as simple or as complex\r\nas the situation calls for.\r\n\r\n## Even simpler usage in Mocha\r\n\r\nIn Mocha, usage can be simplified even further. Include `test-fixture-mocha.js`\r\nafter Mocha in the `<head>` of your document and then fixture elements like so:\r\n\r\n```html\r\n<script>\r\ndescribe('<some-element>', function () {\r\n  var someElement;\r\n\r\n  beforeEach(function () {\r\n    someElement = fixture('SomeElementFixture');\r\n  });\r\n});\r\n</script>\r\n```\r\n\r\nFixtured elements will be automatically restored in the `afterEach` phase of the\r\ncurrent Mocha `Suite`.\r\n\r\n## Data-bound templates\r\n\r\nData-binding systems are also supported, as long as your (custom) template\r\nelements define a `stamp(model)` method that returns a document fragment. This\r\nallows you to stamp out templates w/ custom models for your fixtures.\r\n\r\nFor example, using Polymer 0.8's `dom-template`:\r\n\r\n```html\r\n<test-fixture id=\"bound\">\r\n  <template is=\"dom-template\">\r\n    <span>{{greeting}}</span>\r\n  </template>\r\n</test-fixture>\r\n```\r\n\r\nYou can pass an optional context argument to `create()` or `fixture()` to pass\r\nthe model:\r\n\r\n```js\r\nvar bound = fixture('bound', {greeting: 'ohai thurr'});\r\n```\r\n\r\n## The problem being addressed\r\n\r\nConsider the following `web-component-tester` test suite:\r\n\r\n```html\r\n<!doctype html>\r\n<html>\r\n<head>\r\n  <title>some-element test suite</title>\r\n\r\n  <link rel=\"import\" href=\"../some-element.html\">\r\n</head>\r\n<body>\r\n  <some-element id=\"SomeElementForTesting\"></some-element>\r\n  <script>\r\ndescribe('<some-element>', function () {\r\n  var someElement;\r\n\r\n  beforeEach(function () {\r\n    someElement = document.getElementById('SomeElementForTesting');\r\n  });\r\n\r\n  it('can receive property `foo`', function () {\r\n    someElement.foo = 'bar';\r\n    expect(someElement.foo).to.be.equal('bar');\r\n  });\r\n\r\n  it('has a default `foo` value of `undefined`', function () {\r\n    expect(someElement.foo).to.be.equal(undefined);\r\n  });\r\n});\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\nIn this contrived example, the suite will pass or fail depending on which order\r\nthe tests are run in. It is non-deterministic because `someElement` has\r\ninternal state that is not properly reset at the end of each test.\r\n\r\nIt would be trivial in the above example to simply reset `someElement.foo` to\r\nthe expected default value of `undefined` in an `afterEach` hook. However, for\r\nnon-contrived test suites that target complex elements, this can result in a\r\nlarge quantity of ever-growing set-up and tear-down boilerplate.\r\n\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "test-fixture@1.1.1",
  "dist": {
    "shasum": "a5b42dd89a391023009a5f4ae5da4d784b8107dc"
  },
  "_resolved": "git://github.com/PolymerElements/test-fixture#18144479b7e364cef7936672b56b4512c7e8e1d0",
  "_from": "git://github.com/PolymerElements/test-fixture",
  "_fromGithub": true
}
